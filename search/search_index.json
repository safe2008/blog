{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello World \u00b6 ALGOL BEGIN DISPLAY ( \"HELLO WORLD!\" ) END. ASPECTJ // HelloWorld.java public class HelloWorld { public static void say ( String message ) { System.out.println ( message ) ; } public static void sayToPerson ( String message, String name ) { System.out.println ( name + \", \" + message ) ; } } // MannersAspect.java public aspect MannersAspect { pointcut callSayMessage () : call ( public static void HelloWorld.say* ( .. )) ; before () : callSayMessage () { System.out.println ( \"Good day!\" ) ; } after () : callSayMessage () { System.out.println ( \"Thank you!\" ) ; } } APPLESCRIPT say \"Hello, world!\" ASSEMBLY LANGUAGE global _main extern _printf section .text _main: push message call _printf add esp, 4 ret message: db 'Hello, World' , 10 , 0 BASH (UNIX SHELL) #!/bin/bash STR = \"Hello World!\" echo $STR BASIC 10 PRINT \"Hello, World!\" 20 END C #include <stdio.h> int main ( void ) { printf ( \"hello, world\\n\" ) ; } C++ #include <iostream> int main () { std::cout << \"Hello, world!\\n\" ; return 0 ; } C# using System ; class Program { static void Main ( string [] args ) { Console.WriteLine ( \"Hello, world!\" ) ; } } CAML (OCAML) print_endline \"Hello, world!\" ;; CLOJURE (CLOJURESCRIPT) ( println \"Hello world!\" ) COBOL IDENTIFICATION DIVISION. PROGRAM-ID. hello-world. PROCEDURE DIVISION. DISPLAY \"Hello, world!\" . COFFEESCRIPT console.log \"Hello, World!\" DART main () { print ( 'Hello World!' ) ; } DBASE (FOXPRO) ? \"Hello World\" DELPHI (OBJECT PASCAL) procedure TForm1.ShowAMessage ; begin ShowMessage ( 'Hello World!' ) ; end ; EIFFEL class HELLO_WORLD create make feature make do print ( \"Hello, world!%N\" ) end end ERLANG -module ( hello ) . -export ([ hello_world/0 ]) . hello_world () -> io:fwrite ( \"hello, world\\n\" ) . ELIXIR IO.puts \"Hello World!\" F# open System Console.WriteLine ( \"Hello World!\" ) FORTRAN program helloworld print *, \"Hello world!\" end program helloworld GO package main import \"fmt\" func main () { fmt.Println ( \"Hello, World\" ) } GROOVY (RUBY) println \"Hello World\" HASKELL module Main where main :: IO () main = putStrLn \"Hello, World!\" IBM RPG dcl-s wait char ( 1 ) ; dsply ( 'Hello World!' ) ' ' wait ; *inlr = *on ; JAVA class HelloWorldApp { public static void main ( String [] args ) { System.out.println ( \"Hello World!\" ) ; // Prints the string to the console. } } JAVASCRIPT (ECMASCRIPT) console.log ( \"Hello World!\" ) ; LISP ( print \"Hello world\" ) LOGO TO HELLO PRINT [ Hello world ] END LUA print ( \"Hello World!\" ) MACHINE CODE b8 21 0a 00 00 #moving \"!\\n\" into eax a3 0c 10 00 06 #moving eax into first memory location b8 6f 72 6c 64 #moving \"orld\" into eax a3 08 10 00 06 #moving eax into next memory location b8 6f 2c 20 57 #moving \"o, W\" into eax a3 04 10 00 06 #moving eax into next memory location b8 48 65 6c 6c #moving \"Hell\" into eax a3 00 10 00 06 #moving eax into next memory location b9 00 10 00 06 #moving pointer to start of memory location into ecx ba 10 00 00 00 #moving string size into edx bb 01 00 00 00 #moving \"stdout\" number to ebx b8 04 00 00 00 #moving \"print out\" syscall number to eax cd 80 #calling the linux kernel to execute our print to stdout b8 01 00 00 00 #moving \"sys_exit\" call number to eax cd 80 #executing it via linux sys_call MATHEMATICA (WOLFRAM LANGUAGE) CloudDeploy [ \"Hello, World\" ] MATLAB classdef hello methods function greet ( this ) disp ( 'Hello, World' ) end end end ML print \"Hello world!\\n\" ; NODE.JS console.log ( \"Hello World!\" ) ; OBJECTIVE-C main () { puts ( \"Hello World!\" ) ; return 0 ; } PASCAL program HelloWorld ( output ) ; begin Write ( 'Hello, world!' ) end. PERL print \"Hello, World!\\n\" ; PHP <?php echo \"Hello, World\" ; POWERSHELL Write-Host \"Hello, World!\" PYTHON print ( \"Hello World\" ) R cat ( \"Hello world\\n\" ) RPG dcl-s wait char ( 1 ) ; dsply ( 'Hello World!' ) ' ' wait ; *inlr = *on ; RUBY puts 'Hello World!' RUST fn main () { println! ( \"Hello, world!\" ) ; } SCALA object HelloWorld extends App { println ( \"Hello, World!\" ) } SCHEME ( let (( hello0 ( lambda () ( display \"Hello world\" ) ( newline )))) ( hello0 )) SCRATCH say Hello, World! SELF 'Hello, World!' print. SMALLTALK Transcript show: 'Hello World!' . SWIFT println ( \"Hello, world!\" ) TCL puts \"Hello World!\" TYPESCRIPT console.log ( \"Hello World!\" ) ; Credit to excelwithbusiness.com","title":"\ud83d\udc4b Hello World"},{"location":"#hello-world","text":"ALGOL BEGIN DISPLAY ( \"HELLO WORLD!\" ) END. ASPECTJ // HelloWorld.java public class HelloWorld { public static void say ( String message ) { System.out.println ( message ) ; } public static void sayToPerson ( String message, String name ) { System.out.println ( name + \", \" + message ) ; } } // MannersAspect.java public aspect MannersAspect { pointcut callSayMessage () : call ( public static void HelloWorld.say* ( .. )) ; before () : callSayMessage () { System.out.println ( \"Good day!\" ) ; } after () : callSayMessage () { System.out.println ( \"Thank you!\" ) ; } } APPLESCRIPT say \"Hello, world!\" ASSEMBLY LANGUAGE global _main extern _printf section .text _main: push message call _printf add esp, 4 ret message: db 'Hello, World' , 10 , 0 BASH (UNIX SHELL) #!/bin/bash STR = \"Hello World!\" echo $STR BASIC 10 PRINT \"Hello, World!\" 20 END C #include <stdio.h> int main ( void ) { printf ( \"hello, world\\n\" ) ; } C++ #include <iostream> int main () { std::cout << \"Hello, world!\\n\" ; return 0 ; } C# using System ; class Program { static void Main ( string [] args ) { Console.WriteLine ( \"Hello, world!\" ) ; } } CAML (OCAML) print_endline \"Hello, world!\" ;; CLOJURE (CLOJURESCRIPT) ( println \"Hello world!\" ) COBOL IDENTIFICATION DIVISION. PROGRAM-ID. hello-world. PROCEDURE DIVISION. DISPLAY \"Hello, world!\" . COFFEESCRIPT console.log \"Hello, World!\" DART main () { print ( 'Hello World!' ) ; } DBASE (FOXPRO) ? \"Hello World\" DELPHI (OBJECT PASCAL) procedure TForm1.ShowAMessage ; begin ShowMessage ( 'Hello World!' ) ; end ; EIFFEL class HELLO_WORLD create make feature make do print ( \"Hello, world!%N\" ) end end ERLANG -module ( hello ) . -export ([ hello_world/0 ]) . hello_world () -> io:fwrite ( \"hello, world\\n\" ) . ELIXIR IO.puts \"Hello World!\" F# open System Console.WriteLine ( \"Hello World!\" ) FORTRAN program helloworld print *, \"Hello world!\" end program helloworld GO package main import \"fmt\" func main () { fmt.Println ( \"Hello, World\" ) } GROOVY (RUBY) println \"Hello World\" HASKELL module Main where main :: IO () main = putStrLn \"Hello, World!\" IBM RPG dcl-s wait char ( 1 ) ; dsply ( 'Hello World!' ) ' ' wait ; *inlr = *on ; JAVA class HelloWorldApp { public static void main ( String [] args ) { System.out.println ( \"Hello World!\" ) ; // Prints the string to the console. } } JAVASCRIPT (ECMASCRIPT) console.log ( \"Hello World!\" ) ; LISP ( print \"Hello world\" ) LOGO TO HELLO PRINT [ Hello world ] END LUA print ( \"Hello World!\" ) MACHINE CODE b8 21 0a 00 00 #moving \"!\\n\" into eax a3 0c 10 00 06 #moving eax into first memory location b8 6f 72 6c 64 #moving \"orld\" into eax a3 08 10 00 06 #moving eax into next memory location b8 6f 2c 20 57 #moving \"o, W\" into eax a3 04 10 00 06 #moving eax into next memory location b8 48 65 6c 6c #moving \"Hell\" into eax a3 00 10 00 06 #moving eax into next memory location b9 00 10 00 06 #moving pointer to start of memory location into ecx ba 10 00 00 00 #moving string size into edx bb 01 00 00 00 #moving \"stdout\" number to ebx b8 04 00 00 00 #moving \"print out\" syscall number to eax cd 80 #calling the linux kernel to execute our print to stdout b8 01 00 00 00 #moving \"sys_exit\" call number to eax cd 80 #executing it via linux sys_call MATHEMATICA (WOLFRAM LANGUAGE) CloudDeploy [ \"Hello, World\" ] MATLAB classdef hello methods function greet ( this ) disp ( 'Hello, World' ) end end end ML print \"Hello world!\\n\" ; NODE.JS console.log ( \"Hello World!\" ) ; OBJECTIVE-C main () { puts ( \"Hello World!\" ) ; return 0 ; } PASCAL program HelloWorld ( output ) ; begin Write ( 'Hello, world!' ) end. PERL print \"Hello, World!\\n\" ; PHP <?php echo \"Hello, World\" ; POWERSHELL Write-Host \"Hello, World!\" PYTHON print ( \"Hello World\" ) R cat ( \"Hello world\\n\" ) RPG dcl-s wait char ( 1 ) ; dsply ( 'Hello World!' ) ' ' wait ; *inlr = *on ; RUBY puts 'Hello World!' RUST fn main () { println! ( \"Hello, world!\" ) ; } SCALA object HelloWorld extends App { println ( \"Hello, World!\" ) } SCHEME ( let (( hello0 ( lambda () ( display \"Hello world\" ) ( newline )))) ( hello0 )) SCRATCH say Hello, World! SELF 'Hello, World!' print. SMALLTALK Transcript show: 'Hello World!' . SWIFT println ( \"Hello, world!\" ) TCL puts \"Hello World!\" TYPESCRIPT console.log ( \"Hello World!\" ) ; Credit to excelwithbusiness.com","title":"Hello World"},{"location":"help/","text":"Help \u00b6 Tips about writing in mkdocs. mkdocs.org mkdocs-material codehilite admonition - note block Pymdown Writing in Visual Studio Code Tabs \u00b6 This need pymdownx.tabbed === \"bash\" ``` echo hi ``` === \"python\" ``` print('hi') ``` bash echo hi python print ( 'hi' ) Hightlight \u00b6 This need pymdownx.mark This is a ==highlight==. This is a highlight . Hightlight code changes \u00b6 This need pymdownx.critic location = @gcsfiles { location @gcsfiles { Highlight Code \u00b6 This need pymdownx.superfences ```yaml hl_lines=\"9 10 11 17\" kind: Service apiVersion: v1 metadata: name: dnsmasq spec: selector: name: dnsmasq type: LoadBalancer externalIPs: - a.a.a.a - a.a.a.b ports: - name: dnsmasq-udp port: 53 protocol: UDP targetPort: dnsmasq-udp # loadBalancerIP: a.a.a.a ``` kind : Service apiVersion : v1 metadata : name : dnsmasq spec : selector : name : dnsmasq type : LoadBalancer externalIPs : - a.a.a.a - a.a.a.b ports : - name : dnsmasq-udp port : 53 protocol : UDP targetPort : dnsmasq-udp # loadBalancerIP: a.a.a.a Escape ``` in markdown \u00b6 Wrap it by one more ` ```` ```yaml kind : Service apiVersion : v1 metadata : name : dnsmasq ``` ```` ```yaml kind : Service apiVersion : v1 metadata : name : dnsmasq ``` Link(reference) to internal documents \u00b6 [Writing in Visual Studio Code](snippets/visual-studio.md) [Mac Setup](mac-setup.md) [Help](../help.md)","title":"\ud83c\udf08 Help"},{"location":"help/#help","text":"Tips about writing in mkdocs. mkdocs.org mkdocs-material codehilite admonition - note block Pymdown Writing in Visual Studio Code","title":"Help"},{"location":"help/#tabs","text":"This need pymdownx.tabbed === \"bash\" ``` echo hi ``` === \"python\" ``` print('hi') ``` bash echo hi python print ( 'hi' )","title":"Tabs"},{"location":"help/#hightlight","text":"This need pymdownx.mark This is a ==highlight==. This is a highlight .","title":"Hightlight"},{"location":"help/#hightlight-code-changes","text":"This need pymdownx.critic location = @gcsfiles { location @gcsfiles {","title":"Hightlight code changes"},{"location":"help/#highlight-code","text":"This need pymdownx.superfences ```yaml hl_lines=\"9 10 11 17\" kind: Service apiVersion: v1 metadata: name: dnsmasq spec: selector: name: dnsmasq type: LoadBalancer externalIPs: - a.a.a.a - a.a.a.b ports: - name: dnsmasq-udp port: 53 protocol: UDP targetPort: dnsmasq-udp # loadBalancerIP: a.a.a.a ``` kind : Service apiVersion : v1 metadata : name : dnsmasq spec : selector : name : dnsmasq type : LoadBalancer externalIPs : - a.a.a.a - a.a.a.b ports : - name : dnsmasq-udp port : 53 protocol : UDP targetPort : dnsmasq-udp # loadBalancerIP: a.a.a.a","title":"Highlight Code"},{"location":"help/#escape-in-markdown","text":"Wrap it by one more ` ```` ```yaml kind : Service apiVersion : v1 metadata : name : dnsmasq ``` ```` ```yaml kind : Service apiVersion : v1 metadata : name : dnsmasq ```","title":"Escape ``` in markdown"},{"location":"help/#linkreference-to-internal-documents","text":"[Writing in Visual Studio Code](snippets/visual-studio.md) [Mac Setup](mac-setup.md) [Help](../help.md)","title":"Link(reference) to internal documents"},{"location":"topic/github-actions/","text":"Github Action \u00b6 Github Actions(CI/CD) tricks that official documents didn't mention. This post including hints, tips, snippet, cheatsheet, troubleshooting, notes, how-to. Github Actions: an overview \u00b6 In Actions, the build occurs as follows (see Introduction to GitHub Actions ): event (for example, a pull request or a commit to the repository, see the list here >>> ) triggers the start of the workflow , and the workflow contains jobs job contains a list of steps , and each step contains one or more actions actions are executed on the same runner , and several such actions can be executed within the same workflow at the same time Main components: runner : the Github or self-hosted server that runs the job workflow : a described procedure that includes one or more jobs that is triggered by some event jobs : a set of steps that run on the same runner. If there are several jobs in one workflow, by default they are launched in parallel, but they can be configured to be executed in turn and depend on the results of each other's execution. steps : a task that executes commands or actions. Since steps in one job are performed on one runner, they can exchange data with each other. actions : main \"executable blocks\" - can represent a set of ready-made tasks, or execute ordinary commands Adding a workflow file \u00b6 mkdir -p .github / workflows name : actions-test on : [ push ] jobs : print-hello : runs-on : ubuntu-latest steps : - run : echo \"Hello, world\" Events \u00b6 In Events, you can describe rather complex conditions, according to which you will make a decision on the execution of a workflow. name : actions-test on : push : branches : - master pull_request : branches : - test-branch Scheduled events \u00b6 name : actions-test on : schedule : - cron : '* * * *' Manual start - workflow_dispatch \u00b6 name : actions-test on : workflow_dispatch jobs : print-hello : runs-on : ubuntu-latest steps : - run : echo \"Hello, world\" After that, a button will appear in Actions to start with a choice of a branch: In addition, a set of input data can be added here, using inputswhich at runtime will be saved in the context github.eventand available as variables: name : actions-test on : workflow_dispatch : inputs : userName : description : \"Username\" required : true default : \"test\" jobs : print-hello : runs-on : ubuntu-latest steps : - run : echo \"Username : $ {{github.event.inputs.username}}\" - run : echo \"Actor's username : $ {{github.actor}}\" Webhooks: create \u00b6 In addition pushto the one we have already used, you can configure the start of the workflow for any event in the repository. name : actions-test on : create jobs : print-hello : runs-on : ubuntu-latest steps : - run : | echo \"Event name: $ {{github.event_name}}\" echo \"Actor's username: $ {{github.actor}}\" Environment variables \u00b6 Also, Github Actions supports working with environment variables. name : vars-test on : push env : VAR_NAME : \"Global value\" jobs : print-vars : runs-on : ubuntu-latest steps : # using own varibales - name : \"Test global var as $VAR_NAME\" run : echo \"Test value $VAR_NAME\" - name : \"Test global var as ${{ env.VAR_NAME }}\" run : echo \"Test value ${{ env.VAR_NAME }}\" # using default variables - name : \"Test job var as $GITHUB_REPOSITORY\" run : echo \"Test value $GITHUB_REPOSITORY\" # this will be empty, as default variables are not in the context - name : \"Test job var as ${{ env.GITHUB_REPOSITORY }}\" run : echo \"Test value ${{ env.GITHUB_REPOSITORY }}\" # using 'dynamic' variables - name : \"Set local var\" run : echo \"local_var=local value\" >> $GITHUB_ENV - name : \"Print local var as $local_var\" run : echo \"$local_var\" - name : \"Print local var as ${{ env.local_var }}\" run : echo \"${{ env.local_var }}\" And the result: Secrets \u00b6 Secrets are added in repository settings> Secrets: name : actions-test on : push env : TEST_ENV : ${{ secrets.TEST_SECRET }} jobs : print-hello : runs-on : ubuntu-latest steps : - run : | echo \"Test secret: ${{ secrets.TEST_SECRET }}\" echo \"Test secret: ${{ env.TEST_ENV }}\" Run:","title":"Github Action"},{"location":"topic/github-actions/#github-action","text":"Github Actions(CI/CD) tricks that official documents didn't mention. This post including hints, tips, snippet, cheatsheet, troubleshooting, notes, how-to.","title":"Github Action"},{"location":"topic/github-actions/#github-actions-an-overview","text":"In Actions, the build occurs as follows (see Introduction to GitHub Actions ): event (for example, a pull request or a commit to the repository, see the list here >>> ) triggers the start of the workflow , and the workflow contains jobs job contains a list of steps , and each step contains one or more actions actions are executed on the same runner , and several such actions can be executed within the same workflow at the same time Main components: runner : the Github or self-hosted server that runs the job workflow : a described procedure that includes one or more jobs that is triggered by some event jobs : a set of steps that run on the same runner. If there are several jobs in one workflow, by default they are launched in parallel, but they can be configured to be executed in turn and depend on the results of each other's execution. steps : a task that executes commands or actions. Since steps in one job are performed on one runner, they can exchange data with each other. actions : main \"executable blocks\" - can represent a set of ready-made tasks, or execute ordinary commands","title":"Github Actions: an overview"},{"location":"topic/github-actions/#adding-a-workflow-file","text":"mkdir -p .github / workflows name : actions-test on : [ push ] jobs : print-hello : runs-on : ubuntu-latest steps : - run : echo \"Hello, world\"","title":"Adding a workflow file"},{"location":"topic/github-actions/#events","text":"In Events, you can describe rather complex conditions, according to which you will make a decision on the execution of a workflow. name : actions-test on : push : branches : - master pull_request : branches : - test-branch","title":"Events"},{"location":"topic/github-actions/#scheduled-events","text":"name : actions-test on : schedule : - cron : '* * * *'","title":"Scheduled events"},{"location":"topic/github-actions/#manual-start-workflow_dispatch","text":"name : actions-test on : workflow_dispatch jobs : print-hello : runs-on : ubuntu-latest steps : - run : echo \"Hello, world\" After that, a button will appear in Actions to start with a choice of a branch: In addition, a set of input data can be added here, using inputswhich at runtime will be saved in the context github.eventand available as variables: name : actions-test on : workflow_dispatch : inputs : userName : description : \"Username\" required : true default : \"test\" jobs : print-hello : runs-on : ubuntu-latest steps : - run : echo \"Username : $ {{github.event.inputs.username}}\" - run : echo \"Actor's username : $ {{github.actor}}\"","title":"Manual start - workflow_dispatch"},{"location":"topic/github-actions/#webhooks-create","text":"In addition pushto the one we have already used, you can configure the start of the workflow for any event in the repository. name : actions-test on : create jobs : print-hello : runs-on : ubuntu-latest steps : - run : | echo \"Event name: $ {{github.event_name}}\" echo \"Actor's username: $ {{github.actor}}\"","title":"Webhooks: create"},{"location":"topic/github-actions/#environment-variables","text":"Also, Github Actions supports working with environment variables. name : vars-test on : push env : VAR_NAME : \"Global value\" jobs : print-vars : runs-on : ubuntu-latest steps : # using own varibales - name : \"Test global var as $VAR_NAME\" run : echo \"Test value $VAR_NAME\" - name : \"Test global var as ${{ env.VAR_NAME }}\" run : echo \"Test value ${{ env.VAR_NAME }}\" # using default variables - name : \"Test job var as $GITHUB_REPOSITORY\" run : echo \"Test value $GITHUB_REPOSITORY\" # this will be empty, as default variables are not in the context - name : \"Test job var as ${{ env.GITHUB_REPOSITORY }}\" run : echo \"Test value ${{ env.GITHUB_REPOSITORY }}\" # using 'dynamic' variables - name : \"Set local var\" run : echo \"local_var=local value\" >> $GITHUB_ENV - name : \"Print local var as $local_var\" run : echo \"$local_var\" - name : \"Print local var as ${{ env.local_var }}\" run : echo \"${{ env.local_var }}\" And the result:","title":"Environment variables"},{"location":"topic/github-actions/#secrets","text":"Secrets are added in repository settings> Secrets: name : actions-test on : push env : TEST_ENV : ${{ secrets.TEST_SECRET }} jobs : print-hello : runs-on : ubuntu-latest steps : - run : | echo \"Test secret: ${{ secrets.TEST_SECRET }}\" echo \"Test secret: ${{ env.TEST_ENV }}\" Run:","title":"Secrets"}]}